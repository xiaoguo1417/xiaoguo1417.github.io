<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++输入输出记录</title>
      <link href="/2022/08/18/C++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/08/18/C++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>C++中定义了输入输出流将程序与文件进行了连接，下面对常用的程序读取与输出txt和csv文件流程进行记录。</p><img src="https://cdn.jsdelivr.net/gh/xiaoguo1417/PicHost@main/img/image-20220817195038936.png" alt="image-20220817195038936" style="zoom:80%;" /><h2 id="1-写入文件">1. 写入文件</h2><p>写入文件主要使用==ofstream==类对文件操作，操作步骤为包含文件输入输出的头文件；创建流并打开文件；使用重载的==&lt;&lt;==运算符进行文件写入；写入完毕，关闭文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span><span class="comment">//文件读写的类</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> test[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">ofstream out;</span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;test.csv&quot;</span>);<span class="comment">//文件打开</span></span><br><span class="line"><span class="comment">//或者直接使用 ofstream out(&quot;test.txt&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (out.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;打开文件错误!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写文件，csv以逗号分隔两个数据（txt可自定义分隔），endl换行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">out &lt;&lt; test[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">out &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">out.<span class="built_in">close</span>();<span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-读取文件">2. 读取文件</h2><p>读取文件使用==ifstream==类进行操作，流程与写入时相同，读取时除了可以使用重载的==&gt;&gt;==运算符（逐词读取），还可以使用==getline()==函数（逐行读取）。</p><p>使用cin 和 &gt;&gt; 运算符来输入字符串时，当 cin 读取数据时，它会传递并忽略任何前导白色空格字符（<strong>空格、制表符或换行符</strong>），一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取；</p><p>这里使用的getline()函数定义在头文件string，其四种重载形式如下，其将一个输入流is读取字符串放到str中，默认的停止符delim为’\n’，也就是回车换行符（即遇到换行停止读入），也可以自定义修改这个停止符，如改为’,'等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, string&amp; str, <span class="type">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, string&amp; str, <span class="type">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, string&amp; str)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure><p>在getline()读取很长的字符串后可以使用==isstringstream==进行分割字符串。isstringstream包含于stringstream标准类库（头文件==sstream==），该类库可以向string写入数据，从string读取数据，就像string是一个IO流一样，istringstream完成从string读取数据。使用时先将string类型的字符串放入isstringstream流中，然后使用重载的==&gt;&gt;==逐词读取。</p><h3 id="2-1-读取空格分隔的txt文件">2.1 读取空格分隔的txt文件</h3><p>下面记录将空格为分隔的txt文件读取得到一个二维数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//支持C++风格的串流的输入输出操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">string rowData;<span class="comment">//一行内容</span></span><br><span class="line">istringstream iss;</span><br><span class="line">string dataVal;</span><br><span class="line">vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;dataVec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(in, rowData))</span><br><span class="line">&#123;</span><br><span class="line">        iss.<span class="built_in">clear</span>();</span><br><span class="line">iss.<span class="built_in">str</span>(rowData);<span class="comment">//将一行的内容放入流中</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt;rowDataVec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iss &gt;&gt; dataVal)</span><br><span class="line">&#123;</span><br><span class="line">rowDataVec.<span class="built_in">push_back</span>(<span class="built_in">atof</span>(dataVal.<span class="built_in">c_str</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataVec.<span class="built_in">push_back</span>(rowDataVec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-读取csv文件">2.2 读取csv文件</h3><p>读取csv文件到二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span><span class="comment">//支持C++风格的串流的输入输出操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;test.csv&quot;</span>)</span></span>;</span><br><span class="line">string line;</span><br><span class="line">vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;dataVec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(infile, line))</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">istringstream <span class="title">sin</span><span class="params">(line)</span></span>;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; rowDataVec;</span><br><span class="line">string dataVal;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(sin, dataVal, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">rowDataVec.<span class="built_in">push_back</span>(<span class="built_in">atof</span>(dataVal.<span class="built_in">c_str</span>()));</span><br><span class="line">&#125;</span><br><span class="line">dataVec.<span class="built_in">push_back</span>(rowDataVec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIBSVM的VS2015使用记录</title>
      <link href="/2022/08/12/LIBSVM%E7%9A%84VS2015%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/08/12/LIBSVM%E7%9A%84VS2015%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.csie.ntu.edu.tw/~cjlin/libsvm/">LIBSVM</a>工具箱是台湾大学林智仁（C.JLin）等人开发的一套简单的、易于使用的SVM模式识别与回归机软件包，该软件包利用收敛性证明的成果改进算法，取得了很好的结果。下面对<strong>LIBSVM(Version 3.25)<strong>在</strong>VS2015</strong>中的==分类==使用进行记录。</p><h2 id="1-使用流程">1. 使用流程</h2><p>(1). LIBSVM所要求的格式准备数据集(也可以自行准备数据格式，需自己写获取数据的函数，记录中以LIBSVM官方数据的格式读取为例)；</p><p>(2). 对数据进行简单的<strong>缩放</strong>操作；</p><p>(3). 考虑选用RBF(radial basis function)核参数；</p><p>(4). 如果选用RBF，通过采用<strong>交叉验证</strong>获取最佳参数C与gamma；</p><p>(5). 采用最佳参数C与g对整个训练集进行训练<strong>获取支持向量机模型</strong>；</p><p>(6). 利用获取的模型进行<strong>测试与预测</strong>。</p><h2 id="2-数据格式介绍">2. 数据格式介绍</h2><p>将LIBSVM官网的文件包进行下载，我们在VS中主要用到==svm.h==和==svm.cpp==两个文件，将其放入自己的工程下，在使用时我将有关函数封装为类<strong>ClassificationSVM</strong>。</p><p>在LIBSVM中，与读取特征文件相关的类型为<strong>svm_problem</strong>，其主要在训练和预测过程中记录导入的数据。这个类中有三个元素，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">svm_problem</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">//记录样本总数</span></span><br><span class="line"><span class="type">double</span> *y; <span class="comment">//记录样本所属类别</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">svm_node</span> **x; <span class="comment">//存储所有样本的特征，二维数组，一行存一个样本的所有特征</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<strong>svm_node</strong>类型的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">svm_node</span> <span class="comment">//用来存储输入空间中的单个特征</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> index; <span class="comment">//该特征在特征空间中的维度编号</span></span><br><span class="line"><span class="type">double</span> value; <span class="comment">//该特征的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaoguo1417/PicHost@main/img/1.jpg" alt=""></p><p>这次记录过程中我使用的是官方的<a href="https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multiclass.html#vowel">vowel</a>数据集，数据集中包含11个分类，每个分类包含48个数据，一共528个数据进行模型训练。官方的数据格式为：</p><p>分类号 1：数据1 2：数据2 3：数据3…</p><p>从txt文件读取到数组中的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从官方文件中读取数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassificationSVM::readTxt2</span><span class="params">(<span class="type">const</span> std::string&amp; featureFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dataVec.<span class="built_in">clear</span>();<span class="comment">//dataVec为二维数组，对应svm_problem的x中的数据</span></span><br><span class="line">labels.<span class="built_in">clear</span>();<span class="comment">//labels记录每个数据对应的分类，整型数组</span></span><br><span class="line">featureDim = <span class="number">-1</span>;<span class="comment">//特征数量记录</span></span><br><span class="line">sampleNum = <span class="number">0</span>;<span class="comment">//样本数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//官方标准样式</span></span><br><span class="line">std::ifstream fin;</span><br><span class="line">std::string rowData;<span class="comment">//一行内容</span></span><br><span class="line">std::istringstream iss;</span><br><span class="line">fin.<span class="built_in">open</span>(featureFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存特征数据</span></span><br><span class="line">std::string dataVal;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(fin, rowData))</span><br><span class="line">&#123;</span><br><span class="line">iss.<span class="built_in">clear</span>();</span><br><span class="line">iss.<span class="built_in">str</span>(rowData);</span><br><span class="line"><span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt;rowDataVec;</span><br><span class="line"><span class="comment">// 逐词读取，遍历每一行中的每个词</span></span><br><span class="line"><span class="keyword">while</span> (iss &gt;&gt; dataVal)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第一个数据是label分类标识</span></span><br><span class="line"><span class="keyword">if</span> (first) &#123;</span><br><span class="line">first = <span class="literal">false</span>;</span><br><span class="line">labels.<span class="built_in">push_back</span>(<span class="built_in">atof</span>(dataVal.<span class="built_in">c_str</span>()));</span><br><span class="line">sampleNum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//分割字符串得到冒号后数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>;k &lt; dataVal.<span class="built_in">size</span>();k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dataVal[k] == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">dataVal = dataVal.<span class="built_in">substr</span>(k+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rowDataVec.<span class="built_in">push_back</span>(<span class="built_in">atof</span>(dataVal.<span class="built_in">c_str</span>()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dataVec.<span class="built_in">push_back</span>(rowDataVec);</span><br><span class="line">&#125;</span><br><span class="line">featureDim = dataVec[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-数据缩放">3. 数据缩放</h2><p>缩放的主要优点是避免了较大数值范围内的属性，而支配了较小数值范围内的属性。另一个优点是在计算过程中避免了数值上的困难。缩放输入数据，原始数据范围可能过大或过小，该过程可将数据重新缩放到适当范围使训练与预测速度更快，一般缩放到[0, 1]或[-1, 1]，这里我缩放到[-1, 1]，缩放公式如下：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mtext> lower </mtext><mo>+</mo><mo stretchy="false">(</mo><mtext> upper </mtext><mo>−</mo><mtext> lower </mtext><mo stretchy="false">)</mo><mo>∗</mo><mfrac><mrow><mi>y</mi><mo>−</mo><mi>min</mi><mo>⁡</mo></mrow><mrow><mi>max</mi><mo>⁡</mo><mo>−</mo><mi>min</mi><mo>⁡</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">y^{\prime}=\text { lower }+(\text { upper }-\text { lower }) * \frac{y-\min }{\max -\min }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord"> lower </span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord"> upper </span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord"> lower </span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.3169em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9136em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight">−</span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mop mtight"><span class="mtight">m</span><span class="mtight">i</span><span class="mtight">n</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mop mtight"><span class="mtight">m</span><span class="mtight">i</span><span class="mtight">n</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归一化到[-1, 1]，分为训练时缩放，要写一个缩放的文件；预测时读取这个缩放文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassificationSVM::svmScale</span><span class="params">(<span class="type">bool</span> train_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> *minVals = <span class="keyword">new</span> <span class="type">double</span>[featureDim];</span><br><span class="line"><span class="type">double</span> *maxVals = <span class="keyword">new</span> <span class="type">double</span>[featureDim];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (train_model) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; featureDim;i++)</span><br><span class="line">&#123;</span><br><span class="line">minVals[i] = dataVec[<span class="number">0</span>][i];</span><br><span class="line">maxVals[i] = dataVec[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; dataVec.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; dataVec[i].<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dataVec[i][j] &lt; minVals[j])</span><br><span class="line">minVals[j] = dataVec[i][j];</span><br><span class="line"><span class="keyword">if</span> (dataVec[i][j] &gt; maxVals[j])</span><br><span class="line">maxVals[j] = dataVec[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缩放文件存放每个特征的最大最小值</span></span><br><span class="line"><span class="function">std::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;scale_params.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; featureDim;i++)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; minVals[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">out &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; featureDim;i++)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; maxVals[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::ifstream fin;</span><br><span class="line">std::string rowData;<span class="comment">//一行内容</span></span><br><span class="line">std::istringstream iss;</span><br><span class="line">fin.<span class="built_in">open</span>(<span class="string">&quot;scale_params.txt&quot;</span>);</span><br><span class="line">std::<span class="built_in">getline</span>(fin, rowData);</span><br><span class="line">iss.<span class="built_in">clear</span>();</span><br><span class="line">iss.<span class="built_in">str</span>(rowData);</span><br><span class="line"><span class="type">double</span> dataVal;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 逐词读取，遍历每一行中的每个词</span></span><br><span class="line"><span class="keyword">while</span> (iss &gt;&gt; dataVal)</span><br><span class="line">&#123;</span><br><span class="line">minVals[count] = dataVal;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">std::<span class="built_in">getline</span>(fin, rowData);</span><br><span class="line">iss.<span class="built_in">clear</span>();</span><br><span class="line">iss.<span class="built_in">str</span>(rowData);</span><br><span class="line"><span class="keyword">while</span> (iss &gt;&gt; dataVal)</span><br><span class="line">&#123;</span><br><span class="line">maxVals[count] = dataVal;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; dataVec.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; dataVec[i].<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line">dataVec[i][j] = <span class="number">-1</span> + <span class="number">2</span> * (dataVec[i][j] - minVals[j]) / (maxVals[j] - minVals[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> minVals;</span><br><span class="line"><span class="keyword">delete</span> maxVals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩放之后我们就可以将导入的参数dataVec和labels构造到官方的结构svm_problem中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置prob,prob的定义为：svm_problem prob;</span></span><br><span class="line">prob.l = sampleNum;   <span class="comment">//训练样本数</span></span><br><span class="line">prob.x = <span class="keyword">new</span> svm_node*[sampleNum];  <span class="comment">//特征矩阵</span></span><br><span class="line">prob.y = <span class="keyword">new</span> <span class="type">double</span>[sampleNum];     <span class="comment">//标签矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sampleNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">prob.x[i] = <span class="keyword">new</span> svm_node[featureDim + <span class="number">1</span>]; <span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; featureDim; ++j)</span><br><span class="line">&#123;</span><br><span class="line">prob.x[i][j].index = j + <span class="number">1</span>;</span><br><span class="line">prob.x[i][j].value = dataVec[i][j];</span><br><span class="line">&#125;</span><br><span class="line">prob.x[i][featureDim].index = <span class="number">-1</span>;</span><br><span class="line">prob.y[i] = labels[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-交叉验证">4. 交叉验证</h2><p><a href="https://www.cnblogs.com/pursuit1996/p/5617978.html">交叉验证</a>(Cross Validation)是用来验证分类器的性能一种统计分析方法，基本思想是把在某种意义下将原始数据(dataset)进行分组，一部分做为训练集(train set)，另一部分做为验证集(validation set)，首先用训练集对分类器进行训练,在利用验证集来测试训练得到的模型(model)，以此来做为评价分类器的性能指标。</p><p>这里主要使用K折交叉验证（一般选择5折）去得到最合理的模型中的C和gamma（模型的参数列表如下），官方的tools文件夹下grid.py就是在求解最优化的参数，定义的参数范围时-5 &lt;= log~2~C &lt;= 15，-15 &lt;= log~2~G &lt;= 3，步长均为2，在C++中我们需要调用svm.cpp中的<strong>svm_cross_validation</strong>函数遍历参数来进行交叉验证。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">svm_parameter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> svm_type;</span><br><span class="line"><span class="type">int</span> kernel_type;</span><br><span class="line"><span class="type">int</span> degree;<span class="comment">/* for poly */</span></span><br><span class="line"><span class="type">double</span> gamma;<span class="comment">/* for poly/rbf/sigmoid */</span></span><br><span class="line"><span class="type">double</span> coef0;<span class="comment">/* for poly/sigmoid */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* these are for training only */</span></span><br><span class="line"><span class="type">double</span> cache_size; <span class="comment">/* in MB */</span></span><br><span class="line"><span class="type">double</span> eps;<span class="comment">/* stopping criteria */</span></span><br><span class="line"><span class="type">double</span> C;<span class="comment">/* for C_SVC, EPSILON_SVR and NU_SVR */</span></span><br><span class="line"><span class="type">int</span> nr_weight;<span class="comment">/* for C_SVC */</span></span><br><span class="line"><span class="type">int</span> *weight_label;<span class="comment">/* for C_SVC */</span></span><br><span class="line"><span class="type">double</span>* weight;<span class="comment">/* for C_SVC */</span></span><br><span class="line"><span class="type">double</span> nu;<span class="comment">/* for NU_SVC, ONE_CLASS, and NU_SVR */</span></span><br><span class="line"><span class="type">double</span> p;<span class="comment">/* for EPSILON_SVR */</span></span><br><span class="line"><span class="type">int</span> shrinking;<span class="comment">/* use the shrinking heuristics */</span></span><br><span class="line"><span class="type">int</span> probability; <span class="comment">/* do probability estimates */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交叉验证最优化参数求解</span></span><br><span class="line"><span class="type">double</span>* target = <span class="keyword">new</span> <span class="type">double</span>[prob.l];</span><br><span class="line"><span class="type">int</span> logG, logC;</span><br><span class="line"><span class="type">int</span> bestG, bestC;<span class="comment">//记录最好的参数值</span></span><br><span class="line"><span class="type">int</span> minCount = prob.l;<span class="comment">//记录错误的数量</span></span><br><span class="line">std::vector&lt;<span class="type">double</span>&gt;rates;<span class="comment">//记录每次组合对应的正确率</span></span><br><span class="line"><span class="keyword">for</span> (logC = <span class="number">-5</span>;logC &lt;= <span class="number">15</span>;logC += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (logG = <span class="number">-15</span>;logG &lt;= <span class="number">3</span>;logG += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> c = <span class="built_in">pow</span>(<span class="number">2</span>, logC);</span><br><span class="line"><span class="type">double</span> g = <span class="built_in">pow</span>(<span class="number">2</span>, logG);</span><br><span class="line"><span class="built_in">setParam</span>(c, g);<span class="comment">//对模型参数进行修改</span></span><br><span class="line"><span class="built_in">svm_cross_validation</span>(&amp;prob, &amp;param, <span class="number">5</span>, target);</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; prob.l;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (target[i] != i % <span class="number">11</span>)</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count &lt; minCount) &#123;</span><br><span class="line">minCount = count;</span><br><span class="line">bestC = c;</span><br><span class="line">bestG = g;</span><br><span class="line">&#125;</span><br><span class="line">rates.<span class="built_in">push_back</span>(<span class="number">1.0</span>*(prob.l-count) / prob.l*<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出每对参数及对应概率</span></span><br><span class="line"><span class="function">std::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;rates.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (logC = <span class="number">-5</span>;logC &lt;= <span class="number">15</span>;logC += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (logG = <span class="number">-15</span>;logG &lt;= <span class="number">3</span>;logG += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::string s1 = <span class="string">&quot;log2c=&quot;</span>;</span><br><span class="line">s1 += std::<span class="built_in">to_string</span>(logC);</span><br><span class="line">std::string s2 = <span class="string">&quot;log2g=&quot;</span>;</span><br><span class="line">s2 += std::<span class="built_in">to_string</span>(logG);</span><br><span class="line">std::string s3 = <span class="string">&quot;rate=&quot;</span>;</span><br><span class="line">s3 += std::<span class="built_in">to_string</span>(rates[count1]);</span><br><span class="line">count1++;</span><br><span class="line"></span><br><span class="line">out &lt;&lt; s1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s3 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-模型训练">5. 模型训练</h2><p>模型训练主要调用官方的<strong>svm_train</strong>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;start training&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">svm_model *svmModel = <span class="built_in">svm_train</span>(&amp;prob, &amp;param);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;save model&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">svm_save_model</span>(modelFileName.<span class="built_in">c_str</span>(), svmModel);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;done!&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>训练完成后将在指定的位置modelFileName生成对应的模型文件。</p><h2 id="6-模型测试（预测）">6. 模型测试（预测）</h2><p>模型的测试使用<strong>svm_predict</strong>函数（或svm_predict_probability函数），流程与上面类似，将文件导入并缩放后，无需交叉验证直接使用导入的模型进行预测得到预测的结果，返回值类型为double是因为该函数包含分类和回归两个方面，我们在回归时返回的其实就是我们输入的labels中的一个分类的分类号（int型数据）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassificationSVM::predict</span><span class="params">(<span class="type">const</span> std::string&amp; featureFileName, <span class="type">const</span> std::string&amp; modelFileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取特征文件中的特征及保存模型</span></span><br><span class="line">svm_model *model = <span class="built_in">svm_load_model</span>(modelFileName.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="built_in">readTxt2</span>(featureFileName);</span><br><span class="line"><span class="built_in">svmScale</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从vector中构造prob</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//正确预测计数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; dataVec.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">svm_node *sample = <span class="keyword">new</span> svm_node[featureDim + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; featureDim; ++j)</span><br><span class="line">&#123;</span><br><span class="line">sample[j].index = j + <span class="number">1</span>;</span><br><span class="line">sample[j].value = dataVec[i][j];</span><br><span class="line">&#125;</span><br><span class="line">sample[featureDim].index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//double *probresut = new double[11];</span></span><br><span class="line"><span class="comment">//double resultLabel = svm_predict_probability(model, sample, probresut);</span></span><br><span class="line"><span class="type">double</span> resultLabel2 = <span class="built_in">svm_predict</span>(model, sample);</span><br><span class="line"><span class="keyword">if</span> (resultLabel - labels[i] &lt; <span class="number">1e-5</span>)</span><br><span class="line">count++;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; resultLabel2 &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> possibility = <span class="number">1.0</span>*  count / dataVec.<span class="built_in">size</span>();<span class="comment">//正确率</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-参考及链接">7. 参考及链接</h2><p><a href="https://blog.csdn.net/zilongreco/article/details/41390385">一个入门的DEMO</a></p><p><a href="https://blog.csdn.net/lhanchao/article/details/53367532">主要参考</a>，但这个里面没有交叉验证</p><p>我的<a href="https://github.com/xiaoguo1417/libsvm">完整程序</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LIBSVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/03/hello-world/"/>
      <url>/2022/08/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
